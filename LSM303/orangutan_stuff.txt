// *.lss from
// http://code.google.com/p/pi-robot/source/browse/trunk/pi-robot/line-follower/line-follower/default/line-follower.lss?spec=svn3&r=3
//
// *.map from
// http://code.google.com/p/pi-robot/source/browse/trunk/pi-robot/line-follower/line-follower/default/line-follower.map?spec=svn3&r=3
//

static void nextNote();

// Timer1 overflow interrupt
ISR (TIMER1_OVF_vect)
{
	if (buzzerTimeout-- == 0)
	{
		DISABLE_TIMER1_INTERRUPT();
		sei();		// re-enable global interrupts (nextNote() is very slow)
		TCCR1B = (TCCR1B & 0xF8) | TIMER1_CLK_1;	// select IO clock
		OCR1A = (F_CPU/2) / 1000;			// set TOP for freq = 1 kHz
		OCR1B = 0;						// 0% duty cycle
		buzzerFinished = 1;
		if (buzzerSequence && (play_mode_setting == PLAY_AUTOMATIC))
			nextNote();
	}
}

void OrangutanTime::delayMilliseconds(unsigned int milliseconds)
{
	while (milliseconds--)
	unsigned long ticks_to_microseconds(unsigned long numTicks)
	{
		return OrangutanTime::ticksToMicroseconds(numTicks);
	}
	unsigned long get_ms() { return OrangutanTime::ms(); }
	void delay_ms(unsigned int milliseconds) { OrangutanTime::delayMilliseconds(milliseconds); }
	return value;
}

// this function can be used on a time differential to find out how many microseconds have
// elapsed over a period.  For example:
// unsigned long ticks = OrangutanTime::ticks();
// ... (do something)
// unsigned long elapsedMicroseconds = OrangutanTime::ticksToMicroseconds(OrangutanTime::ticks() - ticks);
unsigned long OrangutanTime::ticksToMicroseconds(unsigned long numTicks)
{
	return (numTicks * 2 + 2) / 5;
}

extern "C" {
	unsigned long get_ticks() { return OrangutanTime::ticks(); }
	unsigned long ticks_to_microseconds(unsigned long numTicks)
	{
		return OrangutanTime::ticksToMicroseconds(numTicks);
	}

void OrangutanTime::delayMilliseconds(unsigned int milliseconds)
{
	while (milliseconds--)
	  delayMicroseconds(1000);
}

void OrangutanTime::init2()
{
	TIMSK2 &= ~(1 << TOIE2);	// disable timer2 overflow interrupt
/*
		TCCR2A |= 0x01;
		TCCR2B &= 0xF0;
		TCCR2B |= 0x01;		// timer2 ticks at 20 MHz (prescaler = 1)
*/

	TCCR2A |= 0x03;		// fast PWM, TOP = 0xFF
	TCCR2B &= 0xF0;
	TCCR2B |= 0x02;		// timer 2 ticks at 2.5 MHz (prescaler = 8)

	TIFR2 |= 1 << TOV2;	// clear timer2 overflow flag
	TIMSK2 |= 1 << TOIE2;	// enable timer2 overflow interrupt
	sei();				// enable global interrupts
}
	static inline void init()
	{
		static unsigned char initialized = 0;

		if (!initialized)
		{
			initialized = 1;
			init2();
		}
	}

// differential time computations would give an incorrect result across an overflow.  Our
// method for tracking elapsed milliseconds gives a correct result when performing a time
// differential across an overflow.
unsigned long OrangutanTime::ms()
{
	init();
	unsigned long value;
	TIMSK2 &= ~(1 << TOIE2);	// disable timer2 overflow interrupt
	value = msCounter;
	TIMSK2 |= 1 << TOIE2;	// enable timer2 overflow interrupt
	return value;
}

	unsigned long get_ticks() { return OrangutanTime::ticks(); }
	unsigned long ticks_to_microseconds(unsigned long numTicks)
	{
		return OrangutanTime::ticksToMicroseconds(numTicks);
	}
	unsigned long get_ms() { return OrangutanTime::ms(); }

// number of ticks (in units of 0.4 us) that have elapsed since OrangutanTime was
// initialized.
unsigned long OrangutanTime::ticks()
{
	init();
	TIMSK2 &= ~(1 << TOIE2);	// disable timer2 overflow interrupt
	unsigned long numTicks = TCNT2 | tickCount;	// TCNT2 is lowest byte of tickCount
// initialized.
unsigned long OrangutanTime::ticks()
{
	init();
	TIMSK2 &= ~(1 << TOIE2);	// disable timer2 overflow interrupt
	unsigned long numTicks = TCNT2 | tickCount;	// TCNT2 is lowest byte of tickCount
	{
		// NOTE: it is important to perform this computation again.  If we use a value of TCNT2 read
		// before we checked for the overflow, it might be something like 255 while it becomes 0 after
		// the overflow.  Using an old value could produce a result that is bigger than it should be.
		// For example, the following line should *NOT* be: numTicks += 256;
		numTicks = TCNT2 | (tickCount + 256);		// compute ticks again and add 256 for the overflow
	}
	TIMSK2 |= 1 << TOIE2;	// enable timer2 overflow interrupt
	return numTicks;
}

// There are some inline ones defined to alias to these in the C
// header files.  Also, delay_us() is only in the header, since it's
// inline assembly code.

extern "C" {
	unsigned long get_ticks() { return OrangutanTime::ticks(); }
}


// resets millisecond counter, but does not reset tick counter
void OrangutanTime::reset()
{
	init();
	TIMSK2 &= ~(1 << TOIE2);	// disable timer2 overflow interrupt
	msCounter = 0;
	us_over_10 = 0;
	TIMSK2 |= 1 << TOIE2;	// enable timer2 overflow interrupt
}
	{
		return OrangutanTime::ticksToMicroseconds(numTicks);
	}
	unsigned long get_ms() { return OrangutanTime::ms(); }
	void delay_ms(unsigned int milliseconds) { OrangutanTime::delayMilliseconds(milliseconds); }
	void time_reset() { OrangutanTime::reset(); }

OrangutanPushbuttons::OrangutanPushbuttons()
{
}

inline void OrangutanPushbuttons::init()
{
	{
		static unsigned char initialized = 0;

		if (!initialized)
		{
			initialized = 1;
		}
	}
}


// initializes I/O pins for use as button inputs
void OrangutanPushbuttons::init2()
{
	BUTTON_DDR &= ~ALL_BUTTONS;		// set the pushbutton pins to be inputs
#ifndef _ORANGUTAN_X2
	BUTTON_PORT |= ALL_BUTTONS;		// enable pullups on the pushbutton pins
#endif // _ORANGUTAN_X2
}

// initializes I/O pins for use as button inputs
void OrangutanPushbuttons::init2()
{
	BUTTON_DDR &= ~ALL_BUTTONS;		// set the pushbutton pins to be inputs
#ifndef _ORANGUTAN_X2
	BUTTON_PORT |= ALL_BUTTONS;		// enable pullups on the pushbutton pins
#endif
	delayMicroseconds(5);			// give pullups time to stabilize
}

// returns the value of any specified buttons that are currently pressed, or 0.
// For example, if the top and middle buttons are both pressed, this method
// will return (TOP_BUTTON | MIDDLE_BUTTON).  The argument 'buttons' can
// refer to multiple buttons using the bitwise OR operator |.
unsigned char OrangutanPushbuttons::isPressed(unsigned char buttons)
{
	init();		// initialize pushbutton I/O pins if necessary
	return BUTTONS_DOWN & buttons;
}
//	return OrangutanPushbuttons::waitForButton(buttons);
//}

extern "C" unsigned char button_is_pressed(unsigned char buttons)
{
	return OrangutanPushbuttons::isPressed(buttons);
}

// and then up for at least 15 ms before reporting the press.  This function
// handles all necessary debouncing and should be called repeatedly in a loop
// with the same button-mask argument.  The argument 'buttons' can refer to 
// multiple buttons using the bitwise OR operator | or (e.g.
// TOP_BUTTON | MIDDLE_BUTTON) or the value ANY_BUTTON.
unsigned char OrangutanPushbuttons::getSingleDebouncedRelease(unsigned char buttons)
{
	static unsigned char state = 0;
	static unsigned long prevTimeMillis = 0;
	static unsigned char mask = 0;
	
	unsigned char buttonsUp = BUTTONS_UP;
#ifndef OrangutanTime_cpp
// More convenient aliases for the static class functions.
// These aliases are only accessible when the file is included from
// another C++ file.
inline unsigned long get_ms() { return OrangutanTime::ms(); }
inline unsigned long millis() { return OrangutanTime::ms(); }
	unsigned long timeMillis = millis();
	
	init();
	switch (state)
	{
		case 0:
			if (~buttonsUp & buttons)				// if one of the specified buttons is down
			{
				mask = ~buttonsUp & buttons;		// mask becomes all of masked down buttons
				prevTimeMillis = timeMillis;
				state = 1;
			}
			break;
			
		case 1:
			if (timeMillis - prevTimeMillis >= 15)	// if 15 ms or longer has elapsed
			{
				if (~buttonsUp & mask)				// and if a masked button is still down
				{
					state = 2;						// proceed to next state
					mask = ~buttonsUp & mask;		// new mask becomes all of masked down buttons
				}
			}
			break;
			
		case 2:
			if (buttonsUp & mask)					// if a masked button is now up
			{
				state = 3;							// proceed to next state
				mask = buttonsUp & mask;			// new mask becomes all of masked up buttons
				prevTimeMillis = timeMillis;
			}
			else if (mask != (~buttonsUp & buttons))	// if our mask becomes inaccurate
			{
				state = 0;							// go back to the initial state
			break;

			break;
			
		case 3:
			if (timeMillis - prevTimeMillis >= 15)	// if 15 ms or longer has elapsed
			{
				if (buttonsUp & mask)				// and if a masked button is still up
				{
					state = 0;						// next state becomes initial state
					return buttonsUp & mask;		// return masked up buttons
				}
				else
				{
					state = 2;						// go back to previous state
			}
			break;
	}
	
	return 0;
}
	return OrangutanPushbuttons::getSingleDebouncedPress(buttons);
}


extern "C" unsigned char get_single_debounced_button_release(unsigned char buttons)
{
	return OrangutanPushbuttons::getSingleDebouncedRelease(buttons);
}

// and then down for at least 15 ms before reporting the press.  This function
// handles all necessary debouncing and should be called repeatedly in a loop
// with the same button-mask argument.  The argument 'buttons' can refer to 
// multiple buttons using the bitwise OR operator | or (e.g.
// TOP_BUTTON | MIDDLE_BUTTON) or the value ANY_BUTTON.
unsigned char OrangutanPushbuttons::getSingleDebouncedPress(unsigned char buttons)
{
	static unsigned char state = 0;
	static unsigned long prevTimeMillis = 0;
	static unsigned char mask = 0;
	
	unsigned char buttonsDown = BUTTONS_DOWN;
	unsigned long timeMillis = millis();
	
	init();
	switch (state)
	{
		case 0:
			if (~buttonsDown & buttons)				// if one of the specified buttons is up
			{
				mask = ~buttonsDown & buttons;		// mask becomes all of masked up buttons
				prevTimeMillis = timeMillis;
				state = 1;
			}
			break;
			
		case 1:
			if (timeMillis - prevTimeMillis >= 15)	// if 15 ms or longer has elapsed
			{
				if (~buttonsDown & mask)			// and if a masked button is still up
				{
					state = 2;						// proceed to next state
					mask = ~buttonsDown & mask;		// new mask becomes all of masked up buttons
				}
			}
			break;
			
		case 2:
			if (buttonsDown & mask)					// if a masked button is now down
			{
				state = 3;							// proceed to next state
				mask = buttonsDown & mask;			// new mask becomes all of masked down buttons
				prevTimeMillis = timeMillis;
			}
			else if (mask != (~buttonsDown & buttons))	// if our mask becomes inaccurate
			{
				state = 0;							// go back to the initial state
			}
			break;
			
		case 3:
			if (timeMillis - prevTimeMillis >= 15)	// if 15 ms or longer has elapsed
			{
				if (buttonsDown & mask)				// and if a masked button is still down
				{
					state = 0;						// next state becomes initial state
					return buttonsDown & mask;		// return masked down buttons
				}
				else
				{
					state = 2;						// go back to previous state
			}
			break;
	}
	
	return 0;
}

	return OrangutanPushbuttons::isPressed(buttons);
}


extern "C" unsigned char get_single_debounced_button_press(unsigned char buttons)
{
	return OrangutanPushbuttons::getSingleDebouncedPress(buttons);
}

// execution will return from this method.  The argument 'buttons' can
// refer to multiple buttons using the bitwise OR operator |.  The
// return value is the ID of the button that was released.  Note that
// this method takes care of button debouncing.
// Example: waitForRelease(TOP_BUTTON | BOTTOM_BUTTON);
unsigned char OrangutanPushbuttons::waitForRelease(unsigned char buttons)
{
	init();		// initialize pushbutton I/O pins if necessary
	do
	{
		while (!(BUTTONS_UP & buttons))	// wait for a button to be released

inline void delay(unsigned int milliseconds) { OrangutanTime::delayMilliseconds(milliseconds); }
// this method takes care of button debouncing.
// Example: waitForRelease(TOP_BUTTON | BOTTOM_BUTTON);
unsigned char OrangutanPushbuttons::waitForRelease(unsigned char buttons)
{
	init();		// initialize pushbutton I/O pins if necessary
	do
		while (!(BUTTONS_UP & buttons))	// wait for a button to be released
			;
			delay(10);						// debounce the button release
	}
	while (!(BUTTONS_UP & buttons));		// if button isn't still released, loop
	return BUTTONS_UP & buttons;			// return the released button(s)
}
	return OrangutanPushbuttons::waitForPress(buttons);
}

extern "C" unsigned char wait_for_button_release(unsigned char buttons)
{
	return OrangutanPushbuttons::waitForRelease(buttons);
}

// execution will return from this method.  The argument 'buttons' can
// refer to multiple buttons using the bitwise OR operator |.  The
// return value is the ID of the button that was pressed.  Note that
// this method takes care of button debouncing.
// Example: waitForPress(TOP_BUTTON | BOTTOM_BUTTON);
unsigned char OrangutanPushbuttons::waitForPress(unsigned char buttons)
{
	init();		// initialize pushbutton I/O pins if necessary
	do
	{
		while (!(BUTTONS_DOWN & buttons))	// wait for a button to be pressed
// this method takes care of button debouncing.
// Example: waitForPress(TOP_BUTTON | BOTTOM_BUTTON);
unsigned char OrangutanPushbuttons::waitForPress(unsigned char buttons)
{
	init();		// initialize pushbutton I/O pins if necessary
	do
		while (!(BUTTONS_DOWN & buttons))	// wait for a button to be pressed
			;
		delay(10);						// debounce the button press
	}
	while (!(BUTTONS_DOWN & buttons));		// if button isn't still pressed, loop
	return BUTTONS_DOWN & buttons;			// return the pressed button(s)
}

// at which point execution will return from this method.  The argument
// 'buttons' can refer to multiple buttons using the bitwise OR operator |.
// The return value is the ID of the button that was pressed and released.
// Note that this method takes care of button debouncing.
// Example: waitForButton(TOP_BUTTON | BOTTOM_BUTTON);
unsigned char OrangutanPushbuttons::waitForButton(unsigned char buttons)
{
  unsigned char pressedButton = waitForPress(buttons);
  waitForRelease(pressedButton);
  return pressedButton;
}

	return OrangutanPushbuttons::waitForRelease(buttons);
}

extern "C" unsigned char wait_for_button(unsigned char buttons)
{
	return OrangutanPushbuttons::waitForButton(buttons);
}

#include "../OrangutanTime/OrangutanTime.h"	// provides access to delay routines

extern "C" unsigned char wait_for_button_press(unsigned char buttons)
{
	return OrangutanPushbuttons::waitForPress(buttons);
}
